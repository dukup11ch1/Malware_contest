#-*- coding: utf-8 -*-
import pefile
import parse_filelist#같은 디렉터리에 있는 py파일 말그대로 file들을 parse한다.
import sys

reload(sys)
sys.setdefaultencoding('utf-8')#혹시나 모르는 인코딩 문제

files = parse_filelist.allfiles(sys.argv[1])#그냥 전부다 가져온다.

for pe in files:
    try:
        pf=pefile.PE(pe)#일단 pefile인지 아닌지
    except:#except 정확하게 뭔지 모르는데 시간없어서 그냥 무조건 처리
        print "may be \""+pe+"\" is not pefile"
        continue
    flag=True#true면 정상, flase면 악성
    for i in range(len(pf.sections)):
        if i == 1 or i==3:#섹션 2번째거나 4번째일때만 검사하자
            data= pf.sections[i].get_data()#데이터를 가져옴
            next_data=data
            while True:
                try:
                    data=next_data
                    offset = 0
                    a=data.find('BOBD')#이부분이 제일 맘에 안듦 원래 다찾고 thread로 동시에 돌리려 했으나 역량 부족
                    if a==-1:
                        break
                    next_data=data[a+4:]#속도지연의 원인. 찾다가 뒤로가고 다시찾다가 뒤로가는 원인
                    offset=ord(data[a+4])#ord는 원래가 unsigned값으로 나옴
                    idx=a+4# +4한 이유는 BOBD뒤에 있는 Offset위치를 얻기 위해
                    if data[idx+offset]=='F':#현재위치+offset=다음 시그니처
                        idx=idx+offset+1#다음 시그니처 뒤에 존재하는 offset위치
                        offset=ord(data[idx])
                        if data[idx+offset]=='N':
                            idx=idx+offset+1
                            offset=ord(data[idx])
                            if data[idx+offset]=='O':
                                idx=idx+offset+1
                                offset=ord(data[idx])
                                
                                if data[idx+offset]=='1':#전부다 맞으면 flag를 false로
                                    flag=False#근데 이거 지금봐서 안건데 반복돌리기전에 flag 체크를 했어야 했다. 이미 악성이라 판정됬는데 굳이 한번 더 돌릴 이유가?
                except:
                    pass
    
    if flag:
        print pe.decode('cp949') + u' 정상'#대부분의 인코딩 오류는 cp949에서 오므로 decode
    else :
        print pe.decode('cp949') + u' 악성'
        